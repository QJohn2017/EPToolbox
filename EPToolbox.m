(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["EPToolbox`"]


Options[FindComplexRoots] = Join[Options[FindRoot], {Seeds -> 50, SeedGenerator -> RandomComplex, Tolerance -> Automatic, Verbose -> False}];
SyntaxInformation[FindComplexRoots] = {"ArgumentsPattern" -> {_, {_, _, _}, OptionsPattern[]},    "LocalVariables" -> {"Table", {2, \[Infinity]}}};
FindComplexRoots::seeds = "Value of option Seeds -> `1` is not a positive integer.";
FindComplexRoots::tol = "Value of option Tolerance -> `1` is not Automatic or a number in [0,\[Infinity]).";

Protect[Seeds];
Protect[SeedGenerator];


Begin["`Private`"];
FindComplexRoots[e1_ == e2_, {z_, zmin_, zmax_}, ops : OptionsPattern[]] := Module[{seeds},
  If[! IntegerQ[Rationalize[OptionValue[Seeds]]] || OptionValue[Seeds] <= 0, 
   Message[FindComplexRoots::seeds, OptionValue[Seeds]]];
  If[! (OptionValue[Tolerance] === Automatic || OptionValue[Tolerance] >= 0), 
   Message[FindComplexRoots::tol, OptionValue[Seeds]]];
  
  seeds = OptionValue[SeedGenerator][{zmin, zmax}, OptionValue[Seeds]];
  
  If[OptionValue[Verbose], Hold[], Hold[FindRoot::lstol]] /. {
    Hold[messageSequence___] :> Quiet[
      DeleteDuplicates[
       Select[
        Check[
           FindRoot[e1 == e2, {z, #},
            Evaluate[Sequence @@ FilterRules[{ops}, Options[FindRoot]]]
            ]
           , ## &[]
           ] & /@ seeds
        , (Re[zmin] < (Re[z] /. #) < Re[zmax] && 
           Im[zmin] < (Im[z] /. #) < Im[zmax]) &]
       , Abs[(z /. #1) - (z /. #2)] < If[
          NumberQ[OptionValue[Tolerance]],
          OptionValue[Tolerance],
          
          10^If[NumberQ[OptionValue[WorkingPrecision]], 
            2 - OptionValue[WorkingPrecision], 2 - $MachinePrecision]
          ] &]
      , {messageSequence}]}
  ]
End[];


RandomSobolComplexes::usage="RandomSobolComplexes[{zmin, zmax}, n] generates a low-discrepancy Sobol sequence of n quasirandom complex numbers in the rectangle with corners zmin and zmax.

RandomSobolComplexes[{{z1min,z1max},{z2min,z2max},\[Ellipsis]},n] generates a low-discrepancy Sobol sequence of n quasirandom complex numbers in the multi-dimensional rectangle with corners {z1min,z1max},{z2min,z2max},\[Ellipsis].
";


Begin["`Private`"];
RandomSobolComplexes[pairsList__, number_] :=Map[
Function[randomsList,
pairsList[[All,1]]+Complex@@@Times[
ReIm[pairsList[[All,2]]-pairsList[[All,1]]],
randomsList
]
],
BlockRandom[
SeedRandom[Method->{"MKL",Method->{"Sobol", "Dimension" -> 2Length[pairsList]}}];
SeedRandom[];
RandomReal[{0, 1}, {number,Length[pairsList],2}]
]
]
RandomSobolComplexes[{zmin_?NumericQ,zmax_?NumericQ},number_]:=RandomSobolComplexes[{{zmin,zmax}},number][[All,1]]
End[];


RandomNiederreiterComplexes::usage="RandomNiederreiterComplexes[{zmin, zmax}, n] generates a low-discrepancy Niederreiter sequence of n quasirandom complex numbers in the rectangle with corners zmin and zmax.

RandomNiederreiterComplexes[{{z1min,z1max},{z2min,z2max},\[Ellipsis]},n] generates a low-discrepancy Niederreiter sequence of n quasirandom complex numbers in the multi-dimensional rectangle with corners {z1min,z1max},{z2min,z2max},\[Ellipsis].";


Begin["`Private`"];
RandomNiederreiterComplexes[pairsList__, number_] :=Map[
Function[randomsList,
pairsList[[All,1]]+Complex@@@Times[
ReIm[pairsList[[All,2]]-pairsList[[All,1]]],
randomsList
]
],
BlockRandom[
SeedRandom[Method->{"MKL",Method->{"Niederreiter", "Dimension" -> 2Length[pairsList]}}];
SeedRandom[];
RandomReal[{0, 1}, {number,Length[pairsList],2}]
]
]
RandomNiederreiterComplexes[{zmin_?NumericQ,zmax_?NumericQ},number_]:=RandomNiederreiterComplexes[{{zmin,zmax}},number][[All,1]]
End[];


DeterministicComplexGrid::usage="DeterministicComplexGrid[{zmin, zmax}, n] generates a grid of about n equally spaced complex numbers in the rectangle with corners zmin and zmax.

DeterministicComplexGrid[{{z1min,z1max},{z2min,z2max},\[Ellipsis]},n] generates a regular grid of about n equally spaced complex numbers in the multi-dimensional rectangle with corners {z1min,z1max},{z2min,z2max},\[Ellipsis]."


Begin["`Private`"];
DeterministicComplexGrid[pairsList_,number_]:=Block[{sep,separationsList,gridPointBasis,k},
sep=NestWhile[0.99#&,Min[Flatten[ReIm[pairsList[[All,2]]-pairsList[[All,1]]]]],Times@@(Floor[Flatten[ReIm[pairsList[[All,2]]-pairsList[[All,1]]]],0.99#]/(0.99#))<=number&];
separationsList=Round[Floor[Flatten[ReIm[pairsList[[All,2]]-pairsList[[All,1]]]],sep]/sep];
gridPointBasis=MapThread[
Function[{l,n},Range[l[[1]],l[[2]],(l[[2]]-l[[1]])/(n+1)][[2;;-2]]],
{Flatten[Transpose[ReIm[pairsList],{1,3,2}],1],separationsList}
];
Flatten[Table[
Table[k[2j-1]+I k[2j],{j,1,Length[pairsList]}],
Evaluate[Sequence@@Table[{k[j],gridPointBasis[[j]]},{j,1,2Length[pairsList]}]]
],Evaluate[Range[1,2Length[pairsList]]]]
]
DeterministicComplexGrid[{zmin_?NumericQ,zmax_?NumericQ},number_]:=DeterministicComplexGrid[{{zmin,zmax}},number][[All,1]]
End[];


cleanContourPlot::usage="cleanContourPlot[plot] Cleans up a contour plot by coalescing complex polygons into single FilledCurve instances. See MM.SE/a/3279 for source and documentation."


Begin["`Private`"];
cleanContourPlot[cp_] :=
 Module[{points, groups, regions, lines},
  groups = 
   Cases[cp, {style__, g_GraphicsGroup} :> {{style}, g}, Infinity];
  points = 
   First@Cases[cp, GraphicsComplex[pts_, ___] :> pts, Infinity];
  regions = Table[
    Module[{group, style, polys, edges, cover, graph},
     {style, group} = g;
     polys = Join @@ Cases[group, Polygon[pt_, ___] :> pt, Infinity];
     edges = Join @@ (Partition[#, 2, 1, 1] & /@ polys);
     cover = Cases[Tally[Sort /@ edges], {e_, 1} :> e];
     graph = Graph[UndirectedEdge @@@ cover];
     {Sequence @@ style, 
      FilledCurve[
       List /@ Line /@ First /@ 
          Map[First, 
           FindEulerianCycle /@ (Subgraph[graph, #] &) /@ 
             ConnectedComponents[graph], {3}]]}
     ],
    {g, groups}];
  lines = Cases[cp, _Tooltip, Infinity];
  Graphics[GraphicsComplex[points, {regions, lines}], 
   Sequence @@ Options[cp]]
  ]
End[];


profileDynamics::usage="profileDynamics[dynamicsConstruct] Produces a profiling suite for the Dynamic statements in its argument.  See MM.SE/a/8047 for source and documentation."!


Begin["`Private`"];
ClearAll[profileDynamics];
Options[profileDynamics] = {"Print" -> False};
profileDynamics[d_, OptionsPattern[]] := With[
  {print = OptionValue["Print"]},
  Module[{counter = {}},
   DynamicModule[
    {diag, start, tag},
    diag[] := CreateDocument[Column[{
        Button["Reset counter", counter = start],
        Dynamic@Grid[Join[
           {{"Dynamic expression", "Count", "Time"}}, 
           MapAt[Short, #, 1] & /@ counter
           ]]
        }]];
    CellPrint@
     ExpressionCell[Button["See profiling information", diag[]]];
    d //. {
       i : Annotation[_, {tag, ___}] :> i,
       e : Dynamic[sth : Except[First[{_, tag}]], rest___] :> With[
         {pos = 1 + Length@counter, 
          catalog = 
           Annotation[
            InputForm@e, {tag, Unique["profileDynamics`annot"]}]},
         AppendTo[counter, {catalog, 0, 0.}];
         Dynamic[First@{Refresh[
              If[print, Print[catalog]]; ++counter[[pos, 2]];
              (counter[[pos, 3]] += First@#; Last@#) &[
               AbsoluteTiming[Refresh[sth]]],
              None], tag}, rest] /; True
         ]
       } // (start = counter; #) &
    ]
   ]
  ]
End[];


End[];
